.. _glossary:

Glossary
========

.. glossary::
   :sorted:

   OTP : OTP
   OTP Value : OTP
   OTP Part: OTP
        A one-time password, which is generated by some mathematical algorithm, usually HMAC,
        based on a seed. The term OTP value is used frequently by privacyIDEA to distinguish
        the OTP from the :term:`OTP PIN`.

   OTP PIN: OTP PIN
   Static Part: OTP PIN
        The OTP PIN is the secret password with which the user authenticates against privacyIDEA.
        The policy action :ref:`otppin_policy` sets the type of password. With this
        password privacyIDEA will identify the tokens for which further actions are taken
        (trigger a challenge or check a given :term:`OTP`).
   Seed
        The seed is a secret which is shared between the privacyIDEA server and the client.
        One-time passwords are calculated based on the seed.

   Count
        The token property ``count`` in privacyIDEA is used to calculate the :term:`OTP` value
        using the HMAC-type algorithms HOTP or TOTP.

   Time Step
        The amount of time in which each totp is valid is called a timestep. Possible values are
        30 or 60(seconds), default is 30. If you haven’t used your otp within that window, it will
        no longer be valid, and you’ll need to request a new one to gain access to your application.

   Revoked Token
        Tokens can be revoked. Usually this means the token is disabled and locked. A locked token can
        not be modified anymore. It can only be deleted. Certain token types like certificate may
        define special actions when revoking a token.

   Orphaned Token
        An orphaned token means, that it has a user assigned, but the user does not exist in the
        user store (anymore).

   Disabled Token
        Tokens can be disabled. Disabled tokens still belong to the assigned user but those tokens
        can not be used to authenticate. Disabled tokens can be enabled again.

   Resolver(UserId)
        UserIdResolvers are connectors to those user stores, the locations,
        where the users are managed. Nowadays this can be LDAP directories or
        especially Active Directory, some times FreeIPA or the Redhat 389 service.
        But classically users are also located in files like /etc/passwd on
        standalone unix systems. Web services often use SQL databases as
        user store.

        Today with many more online cloud services SCIM is also an uprising
        protocol to access userstores.

        privacyIDEA already comes with :ref:`useridresolvers` to talk to all these
        user stores:

        * :ref:`flatfile_resolver`
        * :ref:`ldap_resolver`
        * :ref:`sql_resolver`
        * :ref:`scim_resolver`
        * :ref:`http_resolver`

   Resolver(Machine)
        Machine Resolvers are used to find machines in directories like LDAP,
        Active Directory, puppet, salt, or the /etc/hosts file.

        The idea is for users to be able to authenticate on those client machines.
        Not in all cases an online authentication request is possible,
        so that authentication items can be passed to those client machines.

        In addition you need to define, which application on the client machine
        the user should authenticate to.
        Different application require different authentication items.

        Therefore privacyIDEA can define application types.
        At the moment privacyIDEA knows the application
        ``luks``, ``offline`` and ``ssh``.

   Tokeninfo
        The table “tokeninfo” is used to store additional, long information that is
        specific to the tokentype. E.g. the tokentype “TOTP” has additional entries
        in the tokeninfo table for “timeStep” and “timeWindow”, which are stored in the
        column “Key” and “Value”.

        The tokeninfo is reference by the foreign key to the “token” table.

        Token info can be viewed and partially edited in the GUI. In addition, the
        Token-Janitor can be used to output token info, filter for tokens that have
        specific tokeninfo and set user-defined tokeninfos.

   Token
        A device or item used to authenticate is still called a “token”. All token
        information is stored in an SQL database, while you may choose, which database
        you want to use. privacyIDEA uses SQLAlchemy to map the database to internal objects.
        Thus you may choose to run privacyIDEA with SQLite, MySQL, PostgreSQL, Oracle,
        DB2 or other database.

        PrivacyIDEA supports a great variety of different token types.
        They each have different requirements concerning configuration and how
        the authentication works. This chapter explains the authentication modes, lists the
        supported hardware and software tokens and explains how the token types can be used
        with privacyIDEA.
        Tools which facilitate and automate token enrollment are found in :ref:`enrollment_tools`.

        * :ref:`authentication_modes`
        * :ref:`supported_tokens`
        * :ref:`tokentypes`

   Audit
        The systems provides a sophisticated audit log, that can be viewed in the WebUI.

        The Audit log lists all events the server registers.

        .. figure:: /audit/auditlog.png
           :width: 500

           *Audit Log*

        privacyIDEA comes with a default SQL audit module (see :ref:`code_audit`).

        Starting with version 3.2 privacyIDEA also provides a :ref:`logger_audit` and
        a :ref:`container_audit` which can be used to send privacyIDEA audit log messages
        to services like splunk or logstash.

   Tokenowner
        The owner of a token is the user for whom the token was rolled out.